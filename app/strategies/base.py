from abc import ABC, abstractmethod
from typing import List, Dict, Optional, Any
from datetime import datetime
import pandas as pd
from dataclasses import dataclass
import structlog

from app.data.models.signals import Signal
from app.data.processors.technical import ASXTechnicalAnalyzer
from app.utils.logging import get_trading_logger

logger = structlog.get_logger(__name__)
trading_logger = get_trading_logger(__name__)


@dataclass
class StrategyParameters:
    """Base parameters for all strategies"""
    name: str
    enabled: bool = True
    max_positions: int = 3
    position_size_method: str = "equal_weight"  # equal_weight, kelly, fixed_dollar
    risk_per_trade: float = 0.02  # 2% risk per trade
    max_holding_days: int = 14  # Maximum holding period for swing trades
    min_liquidity: float = 500000  # Minimum daily volume in AUD
    
    # Stop loss and take profit
    stop_loss_method: str = "atr"  # atr, percent, support
    stop_loss_multiplier: float = 2.0
    take_profit_ratio: float = 2.0  # Risk-reward ratio
    
    # Market filters
    min_price: float = 1.00  # Minimum stock price
    max_price: float = 1000.00  # Maximum stock price
    exclude_symbols: List[str] = None
    
    def __post_init__(self):
        if self.exclude_symbols is None:
            self.exclude_symbols = []


@dataclass
class StrategySignal:
    """Signal generated by a strategy"""
    symbol: str
    signal_type: str  # BUY, SELL, CLOSE
    price: float
    confidence: float  # 0.0 to 1.0
    strategy_name: str
    generated_at: datetime
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies
    Provides common functionality for ASX200 swing trading
    """
    
    def __init__(self, parameters: StrategyParameters):
        self.parameters = parameters
        self.analyzer = ASXTechnicalAnalyzer()
        self.active_positions: Dict[str, datetime] = {}  # symbol -> entry_date
        self.position_count = 0
        
        logger.info("Strategy initialized", 
                   strategy=parameters.name,
                   max_positions=parameters.max_positions,
                   risk_per_trade=parameters.risk_per_trade)
    
    @abstractmethod
    def generate_entry_signals(self, data: Dict[str, pd.DataFrame], 
                              current_date: datetime) -> List[StrategySignal]:
        """
        Generate entry signals based on market data
        
        Args:
            data: Dictionary of symbol -> DataFrame with OHLCV + indicators
            current_date: Current trading date
            
        Returns:
            List of entry signals
        """
        pass
    
    @abstractmethod
    def generate_exit_signals(self, data: Dict[str, pd.DataFrame], 
                             current_date: datetime) -> List[StrategySignal]:
        """
        Generate exit signals for existing positions
        
        Args:
            data: Dictionary of symbol -> DataFrame with OHLCV + indicators
            current_date: Current trading date
            
        Returns:
            List of exit signals
        """
        pass
    
    def get_all_signals(self, data: Dict[str, pd.DataFrame], 
                       current_date: datetime) -> List[StrategySignal]:
        """
        Get all signals (entry + exit) for current date
        
        Args:
            data: Market data with technical indicators
            current_date: Current trading date
            
        Returns:
            List of all signals
        """
        if not self.parameters.enabled:
            return []
        
        signals = []
        
        try:
            # Generate exit signals first (higher priority)
            exit_signals = self.generate_exit_signals(data, current_date)
            signals.extend(exit_signals)
            
            # Update position tracking for exits
            for signal in exit_signals:
                if signal.signal_type in ["SELL", "CLOSE"] and signal.symbol in self.active_positions:
                    del self.active_positions[signal.symbol]
                    self.position_count = max(0, self.position_count - 1)
            
            # Generate entry signals if we have capacity
            if self.position_count < self.parameters.max_positions:
                entry_signals = self.generate_entry_signals(data, current_date)
                
                # Filter entry signals to avoid conflicts and respect limits
                filtered_entries = self._filter_entry_signals(entry_signals, current_date)
                signals.extend(filtered_entries)
            
            # Log signal generation
            if signals:
                trading_logger.log_trade_signal(
                    symbol="MULTIPLE" if len(signals) > 1 else signals[0].symbol,
                    signal_type="MIXED" if len(signals) > 1 else signals[0].signal_type,
                    price=0,  # Multiple prices
                    confidence=sum(s.confidence for s in signals) / len(signals),
                    strategy=self.parameters.name
                )
                
                logger.info("Signals generated", 
                           strategy=self.parameters.name,
                           signals=len(signals),
                           entry=[s for s in signals if s.signal_type == "BUY"],
                           exit=[s for s in signals if s.signal_type in ["SELL", "CLOSE"]])
            
        except Exception as e:
            logger.error("Error generating signals", 
                        strategy=self.parameters.name, 
                        error=str(e))
        
        return signals
    
    def _filter_entry_signals(self, signals: List[StrategySignal], 
                             current_date: datetime) -> List[StrategySignal]:
        """Filter entry signals based on strategy constraints"""
        filtered = []
        
        for signal in signals:
            # Skip if already have position in this symbol
            if signal.symbol in self.active_positions:
                continue
            
            # Skip if symbol is excluded
            if signal.symbol in self.parameters.exclude_symbols:
                continue
            
            # Check position limits
            if len(filtered) + self.position_count >= self.parameters.max_positions:
                break
            
            # Apply market filters
            if not self._passes_market_filters(signal):
                continue
            
            filtered.append(signal)
            
            # Track new position
            self.active_positions[signal.symbol] = current_date
            self.position_count += 1
        
        # Sort by confidence and take best signals
        filtered.sort(key=lambda x: x.confidence, reverse=True)
        max_new_positions = self.parameters.max_positions - (self.position_count - len(filtered))
        
        return filtered[:max_new_positions]
    
    def _passes_market_filters(self, signal: StrategySignal) -> bool:
        """Check if signal passes market filters"""
        # Price range filter
        if not (self.parameters.min_price <= signal.price <= self.parameters.max_price):
            return False
        
        # Add more filters as needed
        return True
    
    def calculate_position_metrics(self, symbol: str, entry_price: float, 
                                 data: pd.DataFrame) -> Dict[str, float]:
        """
        Calculate position-specific metrics (stop loss, take profit, etc.)
        
        Args:
            symbol: Stock symbol
            entry_price: Entry price
            data: Technical data for the symbol
            
        Returns:
            Dictionary with position metrics
        """
        try:
            # Calculate stop loss
            stop_loss = self.analyzer.calculate_stop_loss(
                data, entry_price, 
                self.parameters.stop_loss_method, 
                self.parameters.stop_loss_multiplier
            )
            
            # Calculate take profit
            take_profit = self.analyzer.calculate_take_profit(
                data, entry_price, stop_loss, 
                self.parameters.take_profit_ratio
            )
            
            # Calculate position size (placeholder - would need portfolio value)
            portfolio_value = 100000  # TODO: Get from portfolio manager
            if self.parameters.position_size_method == "equal_weight":
                position_value = portfolio_value / self.parameters.max_positions
                position_size = int(position_value / entry_price)
            else:
                position_size = int(10000 / entry_price)  # Default $10k position
            
            return {
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'position_size': position_size,
                'risk_amount': (entry_price - stop_loss) * position_size,
                'reward_amount': (take_profit - entry_price) * position_size
            }
            
        except Exception as e:
            logger.error("Error calculating position metrics", 
                        symbol=symbol, error=str(e))
            return {
                'stop_loss': entry_price * 0.95,  # 5% stop
                'take_profit': entry_price * 1.10,  # 10% target
                'position_size': int(10000 / entry_price),
                'risk_amount': entry_price * 0.05 * int(10000 / entry_price),
                'reward_amount': entry_price * 0.10 * int(10000 / entry_price)
            }
    
    def check_time_based_exits(self, current_date: datetime) -> List[str]:
        """
        Check for positions that should be closed due to time limits
        
        Args:
            current_date: Current trading date
            
        Returns:
            List of symbols to close
        """
        symbols_to_close = []
        
        for symbol, entry_date in self.active_positions.items():
            holding_days = (current_date - entry_date).days
            
            if holding_days >= self.parameters.max_holding_days:
                symbols_to_close.append(symbol)
                logger.info("Time-based exit triggered", 
                           symbol=symbol, 
                           holding_days=holding_days,
                           max_days=self.parameters.max_holding_days)
        
        return symbols_to_close
    
    def get_strategy_status(self) -> Dict[str, Any]:
        """Get current strategy status"""
        return {
            'name': self.parameters.name,
            'enabled': self.parameters.enabled,
            'active_positions': len(self.active_positions),
            'max_positions': self.parameters.max_positions,
            'position_utilization': len(self.active_positions) / self.parameters.max_positions,
            'symbols': list(self.active_positions.keys())
        }
    
    def reset_positions(self) -> None:
        """Reset position tracking (for backtesting)"""
        self.active_positions.clear()
        self.position_count = 0
        
        logger.info("Strategy positions reset", strategy=self.parameters.name)


class StrategyValidator:
    """Validates strategy signals and parameters"""
    
    @staticmethod
    def validate_signal(signal: StrategySignal) -> bool:
        """Validate a trading signal"""
        try:
            # Basic validation
            if not signal.symbol or len(signal.symbol) > 10:
                return False
            
            if signal.signal_type not in ["BUY", "SELL", "CLOSE"]:
                return False
            
            if signal.price <= 0:
                return False
            
            if not (0 <= signal.confidence <= 1):
                return False
            
            # Stop loss validation
            if signal.stop_loss and signal.signal_type == "BUY":
                if signal.stop_loss >= signal.price:
                    return False
            
            # Take profit validation
            if signal.take_profit and signal.signal_type == "BUY":
                if signal.take_profit <= signal.price:
                    return False
            
            return True
            
        except Exception as e:
            logger.error("Error validating signal", error=str(e))
            return False
    
    @staticmethod
    def validate_parameters(params: StrategyParameters) -> List[str]:
        """
        Validate strategy parameters
        
        Returns:
            List of validation errors (empty if valid)
        """
        errors = []
        
        if params.max_positions <= 0:
            errors.append("max_positions must be positive")
        
        if not (0 < params.risk_per_trade <= 0.10):
            errors.append("risk_per_trade must be between 0 and 0.10 (10%)")
        
        if params.max_holding_days <= 0:
            errors.append("max_holding_days must be positive")
        
        if params.min_liquidity <= 0:
            errors.append("min_liquidity must be positive")
        
        if params.stop_loss_multiplier <= 0:
            errors.append("stop_loss_multiplier must be positive")
        
        if params.take_profit_ratio <= 0:
            errors.append("take_profit_ratio must be positive")
        
        if params.min_price <= 0 or params.max_price <= params.min_price:
            errors.append("Invalid price range")
        
        return errors