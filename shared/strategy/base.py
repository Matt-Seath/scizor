"""
Base strategy framework for SCIZOR trading system.

This module provides the fundamental building blocks for implementing trading strategies.
All custom strategies should inherit from BaseStrategy.
"""

from abc import ABC, abstractmethod
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass
import pandas as pd
from pydantic import BaseModel, Field, ConfigDict


class SignalType(Enum):
    """Types of trading signals that strategies can generate."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    STRONG_BUY = "STRONG_BUY"
    STRONG_SELL = "STRONG_SELL"


class OrderType(Enum):
    """Types of orders that can be placed."""
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"


@dataclass
class StrategySignal:
    """
    Represents a trading signal generated by a strategy.
    
    This contains all the information needed to potentially place a trade.
    """
    symbol: str
    signal_type: SignalType
    timestamp: datetime
    price: Decimal
    confidence: float = Field(ge=0.0, le=1.0, description="Signal confidence (0-1)")
    quantity: Optional[int] = None
    order_type: OrderType = OrderType.MARKET
    limit_price: Optional[Decimal] = None
    stop_price: Optional[Decimal] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)
    
    def __post_init__(self):
        """Validate signal after initialization."""
        if self.confidence < 0 or self.confidence > 1:
            raise ValueError("Confidence must be between 0 and 1")
        
        if self.order_type == OrderType.LIMIT and self.limit_price is None:
            raise ValueError("Limit orders require a limit_price")
        
        if self.order_type in [OrderType.STOP, OrderType.STOP_LIMIT] and self.stop_price is None:
            raise ValueError("Stop orders require a stop_price")


class StrategyConfig(BaseModel):
    """Configuration for strategy parameters."""
    model_config = ConfigDict(extra='allow')  # Allow additional parameters
    
    # Basic strategy settings
    name: str = Field(description="Strategy name")
    description: str = Field(default="", description="Strategy description")
    version: str = Field(default="1.0.0", description="Strategy version")
    
    # Trading parameters
    max_position_size: Decimal = Field(default=Decimal("10000"), description="Maximum position size")
    max_positions: int = Field(default=10, description="Maximum number of open positions")
    risk_per_trade: float = Field(default=0.02, ge=0.001, le=0.1, description="Risk per trade (0.001-0.1)")
    
    # Timing parameters
    rebalance_frequency: str = Field(default="daily", description="How often to rebalance")
    lookback_period: int = Field(default=252, description="Days of historical data needed")
    
    # Risk management
    stop_loss_pct: Optional[float] = Field(default=None, description="Stop loss percentage")
    take_profit_pct: Optional[float] = Field(default=None, description="Take profit percentage")
    
    # Custom parameters (will be validated by individual strategies)
    parameters: Dict[str, Any] = Field(default_factory=dict, description="Strategy-specific parameters")


class StrategyMetrics(BaseModel):
    """Performance metrics for a strategy."""
    
    # Return metrics
    total_return: float = 0.0
    annualized_return: float = 0.0
    excess_return: float = 0.0  # vs benchmark
    
    # Risk metrics
    volatility: float = 0.0
    sharpe_ratio: float = 0.0
    sortino_ratio: float = 0.0
    max_drawdown: float = 0.0
    var_95: float = 0.0  # Value at Risk (95%)
    
    # Trade metrics
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: float = 0.0
    profit_factor: float = 0.0
    avg_win: float = 0.0
    avg_loss: float = 0.0
    
    # Portfolio metrics
    avg_position_size: float = 0.0
    max_position_size: float = 0.0
    avg_holding_period: float = 0.0  # days
    
    # Execution metrics
    fill_rate: float = 1.0  # percentage of signals that resulted in fills
    avg_slippage: float = 0.0  # average slippage per trade


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All custom strategies must inherit from this class and implement the required methods.
    This provides a consistent interface for the backtesting engine.
    """
    
    def __init__(self, config: StrategyConfig):
        """Initialize the strategy with configuration."""
        self.config = config
        self.name = config.name
        self.description = config.description
        self.version = config.version
        
        # State tracking
        self.is_initialized = False
        self.last_update = None
        self.data_cache = {}
        self.signal_history: List[StrategySignal] = []
        self.metrics = StrategyMetrics()
        
        # Validate configuration
        self.validate_config()
    
    def validate_config(self) -> None:
        """Validate strategy configuration. Override in subclasses for custom validation."""
        if self.config.risk_per_trade <= 0:
            raise ValueError("risk_per_trade must be positive")
        
        if self.config.max_positions <= 0:
            raise ValueError("max_positions must be positive")
        
        if self.config.lookback_period <= 0:
            raise ValueError("lookback_period must be positive")
    
    @abstractmethod
    def initialize(self, symbols: List[str], start_date: datetime, end_date: datetime) -> None:
        """
        Initialize the strategy before backtesting begins.
        
        Args:
            symbols: List of symbols this strategy will trade
            start_date: Backtest start date
            end_date: Backtest end date
        """
        pass
    
    @abstractmethod
    def generate_signals(self, 
                        data: Dict[str, pd.DataFrame], 
                        timestamp: datetime,
                        portfolio_state: Dict) -> List[StrategySignal]:
        """
        Generate trading signals based on current market data.
        
        Args:
            data: Dictionary of symbol -> OHLCV data (pd.DataFrame)
            timestamp: Current timestamp in backtest
            portfolio_state: Current portfolio state (positions, cash, etc.)
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def update_state(self, 
                    data: Dict[str, pd.DataFrame], 
                    timestamp: datetime,
                    portfolio_state: Dict) -> None:
        """
        Update internal strategy state.
        
        Called after signals are generated and processed.
        Use this to update indicators, rolling windows, etc.
        
        Args:
            data: Dictionary of symbol -> OHLCV data
            timestamp: Current timestamp
            portfolio_state: Updated portfolio state
        """
        pass
    
    def pre_market_open(self, timestamp: datetime, data: Dict[str, pd.DataFrame]) -> List[StrategySignal]:
        """
        Called before market open. Override for pre-market logic.
        
        Args:
            timestamp: Market open timestamp
            data: Available market data
            
        Returns:
            List of pre-market signals (e.g., gap trading)
        """
        return []
    
    def post_market_close(self, timestamp: datetime, data: Dict[str, pd.DataFrame]) -> List[StrategySignal]:
        """
        Called after market close. Override for post-market logic.
        
        Args:
            timestamp: Market close timestamp  
            data: Day's market data
            
        Returns:
            List of after-hours signals
        """
        return []
    
    def on_fill(self, signal: StrategySignal, fill_price: Decimal, fill_quantity: int) -> None:
        """
        Called when a signal results in a trade fill.
        
        Args:
            signal: Original signal that was filled
            fill_price: Actual fill price
            fill_quantity: Actual fill quantity
        """
        # Default implementation just logs the fill
        self.signal_history.append(signal)
    
    def on_partial_fill(self, signal: StrategySignal, fill_price: Decimal, 
                       fill_quantity: int, remaining_quantity: int) -> None:
        """
        Called when a signal results in a partial fill.
        
        Args:
            signal: Original signal
            fill_price: Price of partial fill
            fill_quantity: Quantity filled
            remaining_quantity: Quantity still pending
        """
        pass
    
    def on_order_rejected(self, signal: StrategySignal, reason: str) -> None:
        """
        Called when an order is rejected.
        
        Args:
            signal: Signal that was rejected
            reason: Rejection reason
        """
        pass
    
    def calculate_position_size(self, signal: StrategySignal, 
                              portfolio_value: Decimal, 
                              current_price: Decimal) -> int:
        """
        Calculate position size for a signal.
        
        Default implementation uses fixed risk per trade.
        Override for custom position sizing logic.
        
        Args:
            signal: Trading signal
            portfolio_value: Current portfolio value
            current_price: Current asset price
            
        Returns:
            Position size in shares
        """
        risk_amount = portfolio_value * Decimal(str(self.config.risk_per_trade))
        
        if signal.signal_type in [SignalType.BUY, SignalType.STRONG_BUY]:
            # Calculate shares based on risk and price
            shares = int(risk_amount / current_price)
            return min(shares, int(self.config.max_position_size / current_price))
        
        elif signal.signal_type in [SignalType.SELL, SignalType.STRONG_SELL]:
            # For sells, return the quantity specified in signal or full position
            return signal.quantity or -1  # -1 indicates sell all
        
        return 0
    
    def get_required_data_columns(self) -> List[str]:
        """
        Return list of required data columns.
        
        Default is OHLCV. Override if strategy needs additional data.
        """
        return ['open', 'high', 'low', 'close', 'volume']
    
    def get_warmup_period(self) -> int:
        """
        Return number of days needed for strategy warmup.
        
        This is additional data before backtest start date.
        """
        return self.config.lookback_period
    
    def reset(self) -> None:
        """Reset strategy state for new backtest."""
        self.is_initialized = False
        self.last_update = None
        self.data_cache.clear()
        self.signal_history.clear()
        self.metrics = StrategyMetrics()
    
    def summary(self) -> Dict[str, Any]:
        """Return strategy summary information."""
        return {
            'name': self.name,
            'description': self.description,
            'version': self.version,
            'config': self.config.model_dump(),
            'metrics': self.metrics.model_dump(),
            'signals_generated': len(self.signal_history),
            'is_initialized': self.is_initialized,
            'last_update': self.last_update
        }
    
    def __str__(self) -> str:
        return f"{self.name} v{self.version}"
    
    def __repr__(self) -> str:
        return f"BaseStrategy(name='{self.name}', version='{self.version}')"
